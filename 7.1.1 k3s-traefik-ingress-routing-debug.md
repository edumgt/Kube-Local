# k3s Traefik Ingress 라우팅(404/502) 이해 & 디버깅 정리

> 환경 가정: **k3s 기본 Traefik(Ingress Controller)** 사용  
> 핵심: **Host 헤더 기반 라우팅**, 그리고 **Ingress → Service → Endpoints(EndpointSlice) → Pod** 순서로 디버깅

---

## 1) 결론 요약

- `Ingress.spec.rules[].host` 는 **요청의 Host 헤더가 특정 값일 때만** 해당 Ingress 규칙을 적용한다.
- `hosts` 파일에 `whoami.local` 등을 등록한다는 의미는:
  - **도메인 문자열을 특정 IP로 해석**(DNS 대체)하게 하여,
  - 브라우저/클라이언트가 `http://whoami.local` 로 접속할 때 **Host 헤더도 `whoami.local`** 로 들어가게 만든다는 뜻이다.
- Traefik은 **Ingress Controller 1개(또는 소수)** 가 클러스터 전체의 Ingress를 감시하며,
  - 들어오는 요청을 **규칙(EntryPoint/Host/Path 등)** 으로 매칭하여
  - 해당 Ingress가 가리키는 **Service** 로 전달하고,
  - Service가 가진 **Endpoints(또는 EndpointSlice)** 로 실제 Pod에 프록시한다.

---

## 2) “Traefik 하나로 여러 Ingress를 처리하나?”

네. 아래처럼 `default/whoami-ing` 와 `demo/web-ing` 가 모두 `CLASS: traefik` 인 경우:

```bash
kubectl get ingress -A
NAMESPACE   NAME         CLASS     HOSTS          ADDRESS                                     PORTS   AGE
default     whoami-ing   traefik   whoami.local   192.168.56.10,192.168.56.11,192.168.56.12   80      27d
demo        web-ing      traefik   demo.local     192.168.56.10,192.168.56.11,192.168.56.12   80      19m
```

---
# k3s에서 Ingress YAML에 traefik를 안 적었는데도 CLASS: traefik로 연결되는 이유

> 질문: `default/whoami-ing` 와 `demo/web-ing` 가 둘 다 `CLASS: traefik`로 보이는데  
> Ingress YAML에는 `traefik`를 지정한 적이 없다. **서로 어떻게 연결되는가?**

---

## 1) 결론 요약

Ingress가 Traefik으로 “연결”되는 고리는 **IngressClass**(명시 또는 기본값)와 **Traefik의 Ingress Provider 설정**이다.

- Ingress에 `spec.ingressClassName`을 안 적어도,
  - 클러스터에 **기본(default) IngressClass**가 `traefik`로 지정되어 있으면,
  - 해당 Ingress는 자동으로 **Traefik이 처리할 대상으로 간주**된다.
- 또는 Traefik 설정에 따라 **클래스가 비어있는 Ingress까지** Traefik이 처리하도록 구성될 수 있다.

---

## 2) 왜 `kubectl get ingress`에 CLASS가 `traefik`로 찍히나?

대표적으로 아래 2가지 케이스가 있다.

### (A) `IngressClass/traefik`가 “기본(default)”으로 지정된 경우 (가장 흔함)

k3s는 기본으로 Traefik을 설치하면서 `IngressClass traefik`를 만들고, 이를 **default class**로 표시하는 구성이 흔하다.

- 그래서 Ingress YAML에 아무것도 안 적어도,
- Kubernetes는 “IngressClass를 지정 안 했네? 그럼 default class를 적용하자”
- 결과적으로 `CLASS: traefik`로 표시된다.

#### 확인 명령

```bash
kubectl get ingressclass
kubectl describe ingressclass traefik
```

`describe` 출력에서 아래와 같은 힌트가 보이면 default class로 동작한다.

- `ingressclass.kubernetes.io/is-default-class: "true"`

> 환경/버전에 따라 표현은 조금 다를 수 있으나 핵심은 “traefik class가 기본값이냐”이다.

---

### (B) Traefik이 “IngressClass 지정 없는 Ingress도 처리”하도록 설정된 경우

Traefik은 Kubernetes Ingress provider 설정에 따라

- 특정 class만 처리하거나,
- class가 비어있는 Ingress도 함께 처리하도록

동작할 수 있다. k3s 기본 설치는 Traefik을 “기본 컨트롤러”처럼 쓰게 구성하는 경우가 많아서, Ingress에 class를 안 적어도 Traefik이 잡는 일이 흔하다.

#### 확인 힌트(배포 스펙 args)

```bash
kubectl -n kube-system get deploy traefik -o yaml \
  | egrep -n "kubernetesingress|ingressclass|--providers"
```

---

## 3) “서로 어떻게 연결”되나? (동작 흐름)

Ingress와 Traefik이 연결되는 실제 동작 순서는 다음과 같다.

1. Traefik(컨트롤러)이 Kubernetes API에서 Ingress 리소스들을 **Watch(감시)**
2. Ingress가 생성되면 Traefik은 해당 Ingress가
   - `spec.ingressClassName`으로 지정된 클래스인지,
   - 아니면 default class로 해석되는지,
   - 또는 class가 비어있어도 처리 대상으로 보는지
   를 기준으로 “내가 처리할 리소스인지” 결정
3. 처리 대상이면 Traefik 내부에 **라우터(규칙: Host/Path)** 를 등록
4. 요청이 들어오면 Host/Path 매칭으로 어느 Ingress로 갈지 결정 후,
5. Ingress가 가리키는 backend **Service**로 프록시
6. Service가 가진 **Endpoints/EndpointSlice**를 통해 실제 Pod로 전달

즉 연결 고리는:

**Ingress → (IngressClass 매칭) → Traefik이 룰로 로드 → Service → Endpoints → Pod**

---

## 4) 명시적으로 `traefik`를 박고 싶다면(권장 방식)

최근/정석(v1) 방식은 `spec.ingressClassName`을 사용하는 것이다.

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: web-ing
  namespace: demo
spec:
  ingressClassName: traefik
  rules:
  - host: demo.local
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: web-svc
            port:
              number: 80
```

---

## 5) (호환) annotation 방식(구버전 스타일)

일부 환경에서는 아래 annotation을 사용하는 방식이 남아있다.

```yaml
metadata:
  annotations:
    kubernetes.io/ingress.class: traefik
```

> 신규 구성은 `ingressClassName` 권장.

---

## 6) 내 Ingress가 실제로 무엇으로 잡혔는지 바로 확인

### 6.1 Ingress에 class가 명시되어 있는지 확인

```bash
kubectl -n demo get ingress web-ing -o yaml \
  | egrep -n "ingressClassName|kubernetes.io/ingress.class"

kubectl -n default get ingress whoami-ing -o yaml \
  | egrep -n "ingressClassName|kubernetes.io/ingress.class"
```

- 아무것도 안 나오는데도 `CLASS: traefik`가 찍힌다면 → **default IngressClass** 가능성이 높다.

### 6.2 IngressClass 목록 확인

```bash
kubectl get ingressclass -o wide
```

---

## 7) 한 줄 정리

**Ingress YAML에 Traefik를 적지 않아도, 클러스터의 default IngressClass(traefik) 또는 Traefik의 처리 정책 때문에 Traefik이 Ingress를 자동으로 가져가서 룰로 등록한다.**

---


**하나의 Traefik(컨트롤러)** 가 두 Ingress 모두를 “룰”로 로드하고, 요청이 들어오면:

- `Host: whoami.local` → `default/whoami-ing` 매칭 → `default/Service whoami` → Endpoints → Pod
- `Host: demo.local` → `demo/web-ing` 매칭 → `demo/Service web-svc` → Endpoints → Pod

> Ingress는 네임스페이스 리소스이므로 `demo/web-ing` 가 참조하는 backend `Service/web-svc` 는 **demo 네임스페이스**의 Service다.  
> `default/whoami-ing` 는 **default 네임스페이스**의 Service를 참조한다.

---

## 3) 요청 흐름(아키텍처)

```
Client (Browser/curl)
  → (노드 IP / LB IP:PORT)
  → Traefik Service
  → Traefik Pod (Ingress Controller)
  → Ingress Rule 매칭 (Host/Path)
  → Service (ClusterIP)
  → Endpoints / EndpointSlice
  → Pod IP:containerPort
```

---

## 4) Host 기반 라우팅의 핵심

### 4.1 Ingress 예시

```yaml
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: whoami-ing
spec:
  rules:
  - host: whoami.local
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: whoami
            port:
              number: 80
```

- 위 설정은 “**Host 헤더가 `whoami.local` 인 요청**”만 매칭된다.
- `path: /` + `Prefix` 이므로 `/`, `/abc`, `/anything` 모두 매칭된다.

### 4.2 hosts 파일 등록 의미

`whoami.local` 을 hosts에 등록한다는 건:

- `whoami.local` → `Traefik이 실제로 받는 IP(노드/LB IP)` 로 **이름 해석**을 맞춘다는 의미
- 브라우저에서 `http://whoami.local/` 로 접속하면 **Host 헤더가 whoami.local** 로 자동 설정되므로 Ingress host 조건이 만족된다.

예: (Windows)
`C:\Windows\System32\drivers\etc\hosts`

```txt
192.168.56.10  whoami.local
192.168.56.10  demo.local
```

> **중요:** hosts에 넣는 IP는 “Ingress 리소스의 ADDRESS” 그 자체가 아니라, 실제로 **Traefik(또는 그 Service)이 트래픽을 받는 IP** 여야 한다.

---

## 5) 404 장애 만들기 & 해결하기(Host 헤더)

### 5.1 장애: Host를 지정해놓고 Host 헤더 없이 접속

Ingress 생성(Host: `demo.local`)

```bash
cat <<'YAML' | kubectl apply -f -
apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: web-ing
  namespace: demo
spec:
  rules:
  - host: demo.local
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: web-svc
            port:
              number: 80
YAML
```

Host 헤더 없이 접속(의도적으로 404):

```bash
curl -i "http://<NODEIP>:<NODEPORT>/" | head -n 30
```

#### 404의 의미(중요!)
- 이 404는 보통 **앱(nginx)이 아니라 Traefik이 내는 404**다.
- 뜻: **Ingress 규칙(Host/Path)에 매칭되는 라우터가 없다.**
- 즉, Traefik까지는 도달했으나 **Host 조건이 불만족**일 가능성이 매우 큼.

### 5.2 해결: Host 헤더를 넣어 접속

```bash
curl -i -H "Host: demo.local" "http://<NODEIP>:<NODEPORT>/" | head -n 30
```

- 성공하면 증명되는 것:
  - Traefik이 Ingress 룰을 읽었고,
  - Host 매칭이 되었고,
  - backend Service로 프록시를 붙여서
  - 응답을 정상 반환한다.

---

## 6) 502/504가 뜬다면(백엔드 문제) 체크 순서

> 404는 대개 “Ingress 매칭 실패”  
> 502/504는 대개 “backend(Service/Endpoints/Pod) 문제”

### 6.1 Service/Endpoints(EndpointSlice) 확인

```bash
kubectl -n demo get svc,ep -o wide
```

- Endpoints가 비어있으면:
  - Service selector 라벨 불일치 (가장 흔함)
  - Pod가 Ready가 아님 (Readiness 실패)
  - 혹은 Port가 맞지 않아 endpoints가 형성되지 않음

> 최신에서는 `Endpoints` 대신 `EndpointSlice` 를 더 권장:
```bash
kubectl -n demo get endpointslice
```

### 6.2 Pod 상태/Readiness 확인

```bash
kubectl -n demo get pod -o wide
kubectl -n demo describe pod -l app=web | egrep -n 'Ready|Readiness|probe|Events'
```

- `Running`이어도 `Ready=false` 면 트래픽 대상으로 제외될 수 있다.
- readinessProbe 설정 오류/지연, 리소스 부족, 앱 부팅 지연 등이 원인.

### 6.3 Traefik 로그에서 원인 단서 찾기

```bash
kubectl -n kube-system logs -l app.kubernetes.io/name=traefik --tail=200 \
  | egrep -i 'error|warn|service|router|timeout'
```

자주 보이는 힌트들:
- `service not found` : backend 서비스명/namespace 틀림
- `no endpoints found` : endpoints 비어있음(라벨/ready 문제)
- `connect: connection refused` : 포트 불일치/앱 미기동
- `i/o timeout` / `deadline exceeded` : 네트워크/CNI/리소스 문제 가능

---

## 7) “증명용” 빠른 테스트 명령(추천)

### 7.1 같은 IP로 Host만 바꿔서 라우팅 확인

```bash
curl -i -H "Host: demo.local"   http://192.168.56.10/ | head
curl -i -H "Host: whoami.local" http://192.168.56.10/ | head
```

### 7.2 Ingress가 어느 Service를 바라보는지 확인

```bash
kubectl -n demo describe ingress web-ing
kubectl -n default describe ingress whoami-ing
```

### 7.3 Service가 실제 endpoints를 갖고 있는지 확인

```bash
kubectl -n demo get ep web-svc -o wide
kubectl -n default get ep whoami -o wide
```

### 7.4 클러스터 내부에서 Service DNS로 직접 때려보기(백엔드 자체 점검)

```bash
kubectl -n demo run t --rm -it --image=busybox:1.36 -- sh -lc \
  "wget -qO- http://web-svc:80/ | head"
```

---

## 8) 주의사항(실무 함정)

- Host/Path가 겹치는 Ingress를 여러 개 만들면 Traefik 라우터 우선순위에 의해 **의도치 않은 서비스로 갈 수 있음**
- 지금처럼 Host를 명확히 분리(`demo.local`, `whoami.local`)하면 충돌 위험이 크게 줄어듦.

---

## 9) 한 줄 정리

**Traefik 하나가 모든 Ingress를 룰로 로드하고, 요청의 Host/Path 조건에 맞는 Ingress를 골라 해당 Service의 Endpoints로 프록시한다.**  
`hosts` 등록은 “그 Host로 접속할 때 Host 헤더가 맞게 들어가도록 IP 해석을 맞추는 과정”이다.
